// ============================
// PRISMA CONFIG
// ============================

generator client {
  provider = "prisma-client"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
}

// ============================
// BETTER AUTH MODELS (UNCHANGED)
// ============================

// ============================
// PRISMA CONFIG
// ============================

model User {
  id            String   @id
  name          String
  email         String
  emailVerified Boolean  @default(false)
  image         String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  sessions Session[]
  accounts Account[]

  // SaaS Relations
  tenantUsers TenantUser[]
  projects    Project[]    @relation("ProjectCreators")
  posts       Post[]       @relation("PostAuthors")

  // FIX: This matches the "inviter" relation in the Invite model
  sentInvites Invite[] @relation("UserInvites")

  @@unique([email])
  @@map("user")
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String?
  userAgent String?
  userId    String

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([token])
  @@index([userId])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@index([userId])
  @@map("account")
}

model Verification {
  id         String   @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([identifier])
  @@map("verification")
}

// ============================
// MULTI-TENANT CORE
// ============================

model Tenant {
  id        String   @id @default(uuid())
  name      String
  slug      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  members        TenantUser[]
  projects       Project[]
  billing        Billing?
  socialAccounts SocialAccount[]
  invites        Invite[]
}

model TenantUser {
  id       String     @id @default(uuid())
  tenantId String
  userId   String
  role     TenantRole

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([tenantId, userId])
}

enum TenantRole {
  OWNER
  ADMIN
  MEMBER
  BILLING_MANAGER
}

// ===========================
// INVITE SYSTEM
// ===========================

model Invite {
  id    String @id @default(uuid())
  email String // The email of the person being invited
  token String @unique // The secret key in the URL

  // FIX: Renamed from workspaceId to tenantId for consistency
  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  // FIX: Relation to the User who sent the invite
  inviterId String
  inviter   User   @relation("UserInvites", fields: [inviterId], references: [id])

  role TenantRole @default(MEMBER)

  expiresAt DateTime
  createdAt DateTime @default(now())

  // Prevent duplicate invites for the same person to the same team
  @@unique([email, tenantId])
}

// ============================
// PROJECTS
// ============================

model Project {
  id       String @id @default(uuid())
  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  projectName        String
  projectDescription String?

  createdById String
  createdBy   User   @relation("ProjectCreators", fields: [createdById], references: [id])

  posts Post[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([tenantId])
}

// ============================
// POSTS & CONTENT
// ============================

model Post {
  id        String  @id @default(uuid())
  projectId String
  project   Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  authorId String
  author   User   @relation("PostAuthors", fields: [authorId], references: [id])

  title  String?
  body   Json?
  status PostStatus @default(DRAFT)

  aiPrompt String?

  versions       PostVersion[]
  socialVariants SocialVariant[]
  analytics      Analytics[]
  scheduledJobs  ScheduledJob[]
  media          Media[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([projectId])
}

enum PostStatus {
  DRAFT
  SCHEDULED
  PUBLISHED
  FAILED
}

model PostVersion {
  id     String @id @default(uuid())
  postId String
  post   Post   @relation(fields: [postId], references: [id], onDelete: Cascade)

  content   Json
  createdBy String?
  createdAt DateTime @default(now())
}

model Media {
  id     String  @id @default(uuid())
  postId String?
  post   Post?   @relation(fields: [postId], references: [id], onDelete: Cascade)

  type      MediaType
  url       String
  provider  String // cloudinary, s3
  createdAt DateTime  @default(now())
}

enum MediaType {
  IMAGE
  VIDEO
}

// ============================
// SOCIAL ACCOUNTS & PUBLISHING
// ============================

model SocialAccount {
  id       String @id @default(uuid())
  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  provider       String // twitter, linkedin
  providerUserId String? // twitter user id
  accessToken    String
  refreshToken   String?
  expiresAt      DateTime?

  socialVariants SocialVariant[]

  createdAt DateTime @default(now())
}

model SocialVariant {
  id     String @id @default(uuid())
  postId String
  post   Post   @relation(fields: [postId], references: [id], onDelete: Cascade)

  socialAccountId String
  socialAccount   SocialAccount @relation(fields: [socialAccountId], references: [id])

  content     String
  externalId  String?
  publishedAt DateTime?
}

// ============================
// SCHEDULING & JOBS
// ============================

model ScheduledJob {
  id     String @id @default(uuid())
  postId String
  post   Post   @relation(fields: [postId], references: [id], onDelete: Cascade)

  scheduledFor DateTime
  status       JobStatus @default(PENDING)
  attempts     Int       @default(0)
  lastError    String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum JobStatus {
  PENDING
  RUNNING
  SUCCESS
  FAILED
}

// ============================
// ANALYTICS
// ============================

model Analytics {
  id     String @id @default(uuid())
  postId String
  post   Post   @relation(fields: [postId], references: [id], onDelete: Cascade)

  metric     String
  value      Float
  recordedAt DateTime @default(now())
}

// ============================
// BILLING (PER TENANT)
// ============================

model Billing {
  id       String @id @default(uuid())
  tenantId String @unique
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  stripeCustomerId     String?
  stripeSubscriptionId String?
  plan                 String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
